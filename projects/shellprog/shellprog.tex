\documentclass[12pt,]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{€}
    \setmainfont{"Palatino"}
    \setmonofont[Mapping=tex-ansi]{"Consolas"}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={Einführung in die Shell-Programmierung},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{fancyhdr}
\pagestyle{fancy}
\pagenumbering{arabic}
\lhead{\itshape Einführung in die Shell-Programmierung}
\chead{}
\rhead{\itshape{\nouppercase{\leftmark}}}
\lfoot{v 1.0}
\cfoot{}
\rfoot{\thepage}
\usepackage{longtable,booktabs}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}

\title{Einführung in die Shell-Programmierung}
\date{}

% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\begin{document}
\maketitle

{
\hypersetup{linkcolor=black}
\setcounter{tocdepth}{3}
\tableofcontents
}
\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\section{Einfuehrung in die
Shell-Programmierung}\label{einfuehrung-in-die-shell-programmierung}

Dieses Kapitel widmet sich der Einfuehrung in die Shell-Programmierung.
Hierbei handelt es sich keinesfalls um eine vollstaendige Dokumentation.
Fuer weiterfuehrende Details empfehle ich dringend einen Blick in die
\texttt{man} Pages der jeweiligen Programme sowie der Bash
(\texttt{man\ bash}) zu werfen.

\section{Allgemein}\label{allgemein}

Was ist die Shell? Die Shell ist ein Interpreter, der Kommandos
entsprechend seiner eigenen Syntax interaktiv oder selbstaendig
ausfuehrt. Was im Folgenden als Shell bezeichnet wird, ist ein
Metaprogramm dessen Hauptaufgabe es ist, weitere Programm zu laden. Die
Shell stellt die Schnittstelle zwischen Benutzer und Betriebssystem dar.
In der UNIX-Welt hat sie den Status eines Benutzerprogramms und kann
deshalb nach Belieben ausgetauscht werden .

Im folgenden die wichtigsten Vertreter:

\begin{longtable}[c]{@{}lll@{}}
\toprule
\begin{minipage}[t]{0.10\columnwidth}\raggedright\strut
sh:
\strut\end{minipage} &
\begin{minipage}[t]{0.22\columnwidth}\raggedright\strut
Bourne Shell
\strut\end{minipage} &
\begin{minipage}[t]{0.58\columnwidth}\raggedright\strut
Die Mutter aller Shells
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.10\columnwidth}\raggedright\strut
csh:
\strut\end{minipage} &
\begin{minipage}[t]{0.22\columnwidth}\raggedright\strut
C-Shell
\strut\end{minipage} &
\begin{minipage}[t]{0.58\columnwidth}\raggedright\strut
Shell mit C-aehnlicher Syntax
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.10\columnwidth}\raggedright\strut
ksh:
\strut\end{minipage} &
\begin{minipage}[t]{0.22\columnwidth}\raggedright\strut
Korn Shell
\strut\end{minipage} &
\begin{minipage}[t]{0.58\columnwidth}\raggedright\strut
Maechtige, C-orientierte Shell (Solaris)
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.10\columnwidth}\raggedright\strut
zsh:
\strut\end{minipage} &
\begin{minipage}[t]{0.22\columnwidth}\raggedright\strut
Z-Shell
\strut\end{minipage} &
\begin{minipage}[t]{0.58\columnwidth}\raggedright\strut
Erweiterte, komfortableShell, Bash kompatibel\\
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.10\columnwidth}\raggedright\strut
bash:
\strut\end{minipage} &
\begin{minipage}[t]{0.22\columnwidth}\raggedright\strut
Bourne Again SH
\strut\end{minipage} &
\begin{minipage}[t]{0.58\columnwidth}\raggedright\strut
Erweiterte, komfortable Bourne Shell\\
\strut\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

In diesem Kapitel wollen wir uns mit der Bash beschaeftigen. Sie ist der
Standard Kommandointerpreter unter LINUX. Die Bash ist kompatibel zur
Standard-Bourne-Shell welche von Steven R. Bourne fuer AT\&T Unix
entwickelt wurde.

\section{Erste Schritte}\label{erste-schritte}

Im Grunde ist ein Shellscript nichts anderes als eine Textdatei, in der
Befehlsfolgen enthalten sind. Diese Befehlsfolgen können mit Hilfe von
Schleifen und Variablen gesteuert werden. Man kann solche Befehlsfolgen
auch direkt in der Shell eingeben. Denkbar waeren zum Beispiel
Folgendes:

\begin{verbatim}
asterix% echo "Hallo Europa";echo "Hallo Osterhase..."
Hallo Europa
Hallo Osterhase...
asterix%
\end{verbatim}

Oder aber man schreibt ein kleines Script, daß man dann jederzeit wieder
aufrufen kann. Zu diesem Zwecke öffne man einen Editor seiner Wahl (vi,
emacs, nedit, \ldots{}) und gebe folgendes ein:

\begin{verbatim}
#!/bin/sh
# Das ist ein Kommentar
echo "Hallo Europa"
echo "Hallo Osterhase..."
\end{verbatim}

Danach die Datei unter einem selbstgewaehlten Namen abspeichern und
ausfuehrbar machen. Danach kann das Script gestartet werden.

\begin{verbatim}
asterix% chmod 744 meine_datei.sh
asterix%./meine_datei.sh
Hallo 
Hallo Osterhase...
asterix%
\end{verbatim}

Eine Shell-Skript beginnt mit der Angabe des Kommandointerpreters. Zeile
1 ist also der Pfad zu dem Programm, das die folgenden Zeilen
interpretieren kann. Hier wird auf die Bourne Shell (sh) verwiesen. Die
Datei \texttt{/bin/sh} ist in unserem Fall ein Symlink auf die Bash.\\
Kommentare werden zeilenweise mit \# gekennzeichnet. Das Shellkommando
\texttt{echo} existiert in zwei Formen. Zum einen ist es ein in der
Shell enthaltendes Kommando, zum anderen ist es aber auch eine Datei,
welche sich im Verzeichnis \texttt{/bin} befindet. Linux bietet eine
Vielzahl von Tools und Kommandos, die das Arbeiten auf der Textkonsole
ermöglichen und erleichern. Doch dazu spaeter mehr.

\section{Variablen und Quoting}\label{variablen-und-quoting}

Wie in jeder Programmiersprache gibt es auch in der Shell Variablen. Die
Bash unterscheidet bei Variablen nicht nach Typen. Grundsaetzlich wird
jede Variable erst einmal als String aufgefaßt. Je nach Kontext kann sie
dann auch als Integer interpretiert werden.

Hier nun einige Beispiele, die den Umgang erlaeutern sollen:

\begin{verbatim}
#!/bin/sh
# Wertzuweisung
Variable_1=10
Variable_2="Der Mond ist ein gruener Kaese."
Variable_3="A B  C    D"
Variable_4=$(hostname) # alte Schreibweise: Variable_4=`hostname`
# Wertabfrage
echo \$Variable_1 = $Variable_1
echo "\$Variable_2 = $Variable_2"
echo '$Variable_1 + $Variable_2' = ${Variable_1}${Variable_2}
echo $Variable_3
echo "$Variable_3"
echo $Variable_4
\end{verbatim}

Ergibt:

\begin{verbatim}
$Variable_1 = 10
$Variable_2 = Der Mond ist ein gruener Kaese.
$Variable_1 + $Variable_2 = 10Der Mond ist ein gruener Kaese.
A B C D
A B  C   D
asterix
\end{verbatim}

Um \texttt{\$\ \textbackslash{}\ "} auf dem Bildschirm darzustellen zu
können, muessen sie wie folgt maskiert werden:
\texttt{\textbackslash{}\$\ \textbackslash{}\textbackslash{}\ \textbackslash{}"}.\\
In Zeile 6 wird die Shell angewiesen, erst den rechten Teil der
Variablenzuweisung auszufuehren, naemlich den Befehl \texttt{hostname}.
Dies wird durch \$(\ldots{}) oder ``Backquotes'' erreicht . Die Variable
wird also mit dem Hostnamen des jeweiligen Rechners belegt.

Zu lange Befehlszeilen können mit einem \texttt{\textbackslash{}}
getrennt werden.

\begin{verbatim}
#!/bin/sh
echo "Dies ist ein wahnsinnig langer, sinnfreier und \
  unglaublich ueberfluessiger Satz."
\end{verbatim}

\subsection{Spezielle Typen von
Variablen}\label{spezielle-typen-von-variablen}

\begin{description}
\tightlist
\item[\textbf{local variables}]
Diese sind nur innerhalb eines Code Blocks (\{\ldots{}\}) oder einer
Funktion gueltig und werden mit \texttt{local\ Variable} definiert.
\item[\textbf{environmental variables}]
Sie bestimmen das Erscheinungsbild der Shell und dienen der Anpassung
ihres Verhaltens in der Systemumgebung. Die Prozessumgebung wird vom
Elternprozeß an seine Kinder vererbt. D.h. alle Umgebungsvariablen der
Bash werden an die von ihr gestarteten Prozesse weitergegeben. Die
Kommandos \texttt{printenv} und \texttt{export} geben alle
Umgebungsvariablen aus. Mit dem \texttt{set} Kommando könne
Umgebungsvariablen gesetzt werden.
\end{description}

\subsection{Quotierung}\label{quotierung}

Quotierung wird benutzt, um die spezielle Bedeutung von Kontrollzeichen,
reservierten Wörtern und Namen auszuschalten. Es gibt 3 Formen:

\begin{description}
\tightlist
\item[\textbf{Fluchtsymbol}]
Es entwertet das unmittelbar folgende Sonderzeichen. Ein durch
\texttt{\textbackslash{}} entwertetes Zeilenende wird ignoriert.
\item[\textbf{Hochkomma \texttt{\textquotesingle{}} (Quote)}]
Von Hochkomma eingeschlossene Worte werden von der Shell nicht weiter
bearbeitet. Allerdings darf ein Hochkomma nicht in Hochkommas
eingeschlossen sein. Auch nicht, wenn es durch \texttt{\textbackslash{}}
maskiert ist.
\item[\textbf{Anfuehrungszeichen \texttt{"} ~(Doublequotes)}]
Von in Anfuehrungszeichen eingeschlossenen Wörtern erkennt die Shell nur
die Sonderzeichen \texttt{\$\ \textquotesingle{}\ \textbackslash{}} als
solche. Das Fluchtsymbol behaelt seine Bedeutung fuer die Zeichen
\texttt{\$\ \textquotesingle{}\ "\ \textbackslash{}} oder dem
Zeilenende.
\end{description}

\section{Arrays}\label{arrays}

Die Bash unterstuetzen auch eindimensionale Arrays. Diese können mit
\texttt{declare\ -a\ Variable} initialisiert werden, muessen aber nicht.
Einzelnen Elemente des Arrays werden mit \texttt{\$\{variable{[}xx{]}\}}
angesprochen.

\begin{verbatim}
#!/bin/bash
array=( zero one two three four five )
array[6]="Dieser Text ist ein Element des Arrays"

echo ${array[0]}        # zero
echo ${array[1]}        # one
echo ${array:0}         # zero
                        # Parametererweiterung, erstes Element.
echo ${array:1}         # ero
                        # Parametererweiterung, erstes Element,
                        # Start an Position #1 (2. Buchstabe).
echo ${array[1]:1}      # ne
                        # Parametererweiterung, zweites Element,
                        # Start an Position #1 (2. Buchstabe).
echo ${#array[2]}       # 3
                        # Laenge des dritten Elements.
element_count=${#array[@]}      # oder
element_count=${#array[*]}      # Anzahl der Elemente: 7
\end{verbatim}

\section{Kommandosubstitution}\label{kommandosubstitution}

Die Kommadosubstituton erlaubt es, die Ausgabe eines Kommandos direkt an
eine Variable zu uebergeben. Zwei Formen sind möglich:

\$(\texttt{Kommando}) oder `\texttt{Kommando}`

Bei der Substitution mit Backquotes (nicht Hochkomma!) muessen
Sonderzeichen maskiert werden. Bei der Klammervariante bleiben alle
Zeichen unveraendert.

Damit laeßt sich z.B. der Inhalt eines Textfiles in einen Array laden.

\begin{verbatim}
#!/bin/bash
filename=sample_file
# cat sample_file
#
# 1 a b c
# 2 d e fg
declare -a array1
array1=($(cat "$filename" | tr '\n' ' '))
 # Loads contents
 # of $filename into array1.
 # list file to stdout.
 # change linefeeds in file to spaces.
echo ${array1[@]}
 # List the array:
 # 1 a b c 2 d e fg
 #
 #  Each whitespace-separated "word" in the file
 #+ has been assigned to an element of the array.
element_count=${#array1[*]}
echo $element_count          # 8
\end{verbatim}

\section{1.6 Klammererweiterung}\label{klammererweiterung}

Die Klammererweiterung erzeugt aus einer, in geschweiften Klammern
eingeschlossenen, Liste von Bausteinen mehrere Zeichenketten. Zum
Beispiel erzeugt der Befehl:\\
\texttt{mkdir\ \textasciitilde{}/\{dir1,dir2\}}\\
die Verzeichnisse dir1 und dir2 im Homeverzeichnis. Der Befehl\\
\texttt{mkdir\ \textasciitilde{}/\{dir1,dir2\}\{1,2,3\}}\\
die Verzeichnisse dir11, dir12, dir13, dir21, dir22 und dir23.

\section{Parameter}\label{parameter}

\subsection{Positionsparameter}\label{positionsparameter}

Einem Shellskript können beim Aufruf auch Parameter mitgegeben werden.

\begin{verbatim}
COMMAND Parameter1 Parameter2 ...
\end{verbatim}

Diese Parameter lassen sich im Script mit \texttt{\$1,\ \$2,\ ...}
abfragen. Ab dem 10. uebergebenen Parameter muessen geschweifte Klammern
gesetzt werden (\texttt{\$\{10\}}).

Mit dem \texttt{shift}-Kommando ist es möglich, die Positionsparameter
nach links zu verschieben. Das bedeutet, daß der zweite Parameter der
Erste wird, der Dritte der Zweite usw. . \texttt{\$0} (der Scriptname)
bleibt unberuehrt. Dieses Kommando macht zum Beispiel bei Funktionen
Sinn:

\begin{verbatim}
#!/bin/bash
multiply ()           # multipliziert die uebergebenen Parameter
{                     # Anzahl der Parameter ist variabel
  local product=1
  until [-z "$1" ]   # Until nutzt den ersten uebergebenen Parameter ...
  do
  let "product *= $1"
  shift
  done
  echo $product         #  wird nicht auf STDOUT ausgegeben,
}                       #  wenn es an eine Variable uebergeben wird
mult1=15383; mult2=25211
val1=`multiply $mult1 $mult2`
echo "$mult1 X $mult2 = $val1"
                        # 387820813
\end{verbatim}

\subsection{Spezialparameter}\label{spezialparameter}

\begin{longtable}[c]{@{}ll@{}}
\toprule
\texttt{\$*} & bezeichnet alle Positionsparameter von 1 an. In
Anfuehrungszeichen gesetzt, steht ``\texttt{\$*}`' fuer ein einziges
Wort, bestehend aus dem Inhalt aller Positionsparameter, mit dem ersten
``internen Feldseperator'' (meistens Leerzeichen, Tab und Zeilenende)
als Trennzeichen.\tabularnewline
\texttt{\$@} & bezeichnet alle Positionsparameter von 1 an. In
Anfuehrungszeichen gesetzt, wird es durch die Werte der einzelnen
Positionsparameter (jeweils ein einzelnes Wort) ersetzt.\tabularnewline
\texttt{\$\#} & Anzahl der Positionsparameter\tabularnewline
\texttt{\$?} & Rueckgabewert (Status) des zuletzt ausgefuehrten
Kommandos\tabularnewline
\texttt{\$-} & steht fuer die Optionsflags (von \texttt{set} oder aus
der Kommandozeile).\tabularnewline
\texttt{\$\$} & Prozessnummer der Shell\tabularnewline
\texttt{\$!} & Prozessnummer des zuletzt im Hintergrund aufgerufenen
Kommandos\tabularnewline
\texttt{\$0} & Name des Shellscripts\tabularnewline
\texttt{\$\_} & letztes Argument des zuletzt ausgefuehrten
Kommandos\tabularnewline
\bottomrule
\end{longtable}

\section{Parametererweiterung}\label{parametererweiterung}

\begin{description}
\tightlist
\item[\textbf{\$\{}\emph{Parameter}\textbf{\}}]
Laeßt sich ein Variablenname nicht eindeutig von den darauffolgenden
Zeichen trennen, oder besteht ein Positionsparameter aus mehr als einer
Ziffer, muß dieser Parameter in geschweifte Klammern gesetzt werden.
\end{description}

Die folgenden Konstruktionen stellen verschiedene Arten bedingter
Parametererweiterung dar. Enthaelt die Konstruktion einen Doppelpunkt,
so wird der Parameter darauf hin getestet, ob er leer oder ungesetzt
ist. Wird der Doppelpunkt in diesen Konstruktionen weggelassen, wird nur
darauf getestet, ob er gesetzt (auch leer!) oder ungesetzt ist.

Parametererweiterungen eigenen sich z.B. fuer die Defaultwertzuweisung
bei Variablen. Sie duerfen nur als Bestandteil eines Kommandos oder
einer Zuweisung durchgefuehrt werden. Soll eine Parametererweiterung als
einzelnes Kommando stehen, beispielsweise bei einer Fehlermeldung, dann
muß die Zeile mit einem Doppelpunkt begonnen werden.

\begin{description}
\item[\textbf{\$\{}\emph{Parameter:-default}\}****]
Wenn der \emph{Parameter} ungesetzt oder leer ist, wird \emph{default}
anstelle des gesamten Ausdrucks eingesetzt.
\item[\textbf{\$\{}\emph{Parameter:=default}\}****]
Wenn der \emph{Parameter} ungesetzt oder leer ist, wird der Inhalt von
\emph{default} dem Parameter zugewiesen und der neue \emph{Parameter}
eingesetzt. Positionsparametern und Spezialparametern kann allerdings
auch auf diese Weise kein Wert zugewiesen werden.
\item[\textbf{\$\{}\emph{Parameter:?err\_msg}\}****]
gibt eine Fehlermeldung wenn der \emph{Parameter} leer oder ungesetzt
ist. \emph{err\_msg} wird als Fehlermeldung auf STDERR ausgegeben. Ist
der \emph{Parameter} gueltig gesetzt, wird sein Inhalt eingesetzt.
\item[\textbf{\$\{}\emph{Parameter:+alt\_value}\}****]
erzwingt die Benutzung eines anderen Wertes. Wenn der \emph{Parameter}
weder leer, noch ungesetzt ist, wird der Inhalt von \emph{alt\_value}
eingesetzt. Sonst wird nichts eingesetzt.
\item[\textbf{\$\{}\emph{Parameter:Offset:Laenge}\}****]
Hier wird \emph{Parameter}, von \emph{Offset} an, mit der Laenge
\emph{Laenge} neu gesetzt.
\item[\textbf{\$\{}\emph{\#Parameter}\}****]
gibt die Anzahl der Zeichen im Parameter wieder.
\item[\textbf{\$\{}\emph{var\#Pattern}\}** und
\$\{\textbf{\emph{var\#\#Pattern}\}}**]
entfernt den uebereinstimmenden Teil von \emph{Pattern} in \emph{var}
beginnend von links. Bei \# wird das kuerzeste treffende Stueck
entfernt, bei \#\# das Laengste.
\item[\textbf{\$\{}\emph{var\%Pattern}\}** und
\$\{\textbf{\emph{var\%\%Pattern}\}}**]
entfernt den uebereinstimmenden Teil von \emph{Pattern} in \emph{var}
beginnend von rechts. Bei \% wird das kuerzeste treffende Stueck
entfernt, bei \%\% das Laengste.
\item[\textbf{\$\{}\emph{var/Pattern/Replacement}\}** und
\$\{\textbf{\emph{var/Pattern//Replacement}\}}**]
Das größte auf \emph{Pattern} passende Stueck in \emph{var} wird durch
\emph{Replacement} ersetzt. Bei / wird einmal ersetzt, bei // wird jede
auftretende uebereinstimmung ersetzt. Werden Positionsparameter oder
Arrays uebergeben, wird das Kommando auf jeder einzelnen Parameter bzw.
jedes Feld angewandt.

\section{!/bin/bash}\label{binbash}

leer= default=``voll'' string=``1234567890'' array=( zero one two three
four five )

echo \({leer-\)default\} \# gibt nichts aus, denn \$leer ist definiert
echo \({undef-\)default\} \# gibt ``voll'' aus, denn \# \$undef ist
nicht definiert echo \({leer:-\)default\} \# gibt ``voll'' aus (:)

\begin{description}
\tightlist
\item[default\_filename=generic.data]
\$\{1:?``Dateiname wird auf\\
generic.data gesetzt.''\} \# Fehlermeldung, wenn \$1 fehlt
\end{description}

filename=\({1:=\)default\_filename\} \# setzen des Parameters

leer=\({leer:+\)default\} \# sollte leer nicht NULL sein, \# wird er mit
``voll'' belegt

echo \$\{string:0:1\} \# von links beginnend mit 0 und einem Zeichen: 1
echo \$\{string:(-3):2\} \# von rechts und 2 Zeichen: 89

laeng\_string=\$\{\#string\} \# ergibt 10 echo
\({#array} # Laenge des ersten Elements: 4 element_count=\)\{\#array{[}@{]}\}
\# oder element\_count=\$\{\#array{[}*{]}\} \# Anzahl der Elemente: 6

var1=abcd12345abc6789 pattern1=a\emph{c \# } (wildcard) trifft alles
zwischen `a' und `c' pattern2=b*9 \# alles zwischen `b' und `9' echo
\({var1#\)pattern1\} \# d12345abc6789 echo \({var1##\)pattern1\} \# 6789
echo \({var1%\)pattern2\} \# abcd12345a echo \({var1%%\)pattern2\} \# a

echo \$\{pattern1/abc/ABC\} \# ``abcd12345abc6789'' -\textgreater{}
``ABCd12345abc6789'' echo \$\{pattern1//abc/ABC\} \#
``abcd12345abc6789'' -\textgreater{} ``ABCd12345ABC6789''
\end{description}

\section{Bedingte Ausfuehrung}\label{bedingte-ausfuehrung}

Wie in jeder Programmiersprache, können Kommandos auch miteinander
verknuepft werden.

\begin{description}
\tightlist
\item[\textbf{COMMAND1 \&\& COMMAND2}]
stellen eine logische UND-Verknuepfung dar. Wurde Kommando1 fehlerfrei
ausgefuehrt (exit status 0 heißt Abarbeitung ohne Fehler), wird auch
Kommando2 ausgefuehrt.
\item[\textbf{COMMAND1 \textbar{}\textbar{} COMMAND2}]
Stellen eine logische ODER-Verknuepfung dar. Kommando2 wird nur
ausgefuehrt, wenn bei Kommando1 ein Fehler aufgetreten ist.
\end{description}

\section{Tests, Verzweigungen und
Schleifen}\label{tests-verzweigungen-und-schleifen}

\subsection{Statement if~\ldots{}~then}\label{statement-ifthen}

Syntax:
\texttt{if\ Liste\ then\ Liste\ {[}elif\ Liste\ then\ Liste...{]}{[}else\ Liste{]}\ fi}

If~\ldots{}~then Konstruktionen ueberpruefen, ob der Exit-Status einer
Liste von Kommandos 0 ist. Ist dies der Fall, werden weitere,
entsprechend definierte, Kommandos ausgefuehrt.

Im folgenden Beispiel wird mit dem Kommando \texttt{grep} in einer
Textdatei nach Zeilen, die das Wort ``Bash'' enthalten, gesucht.
Existieren solche Zeilen, gibt \texttt{grep} als Exit-Status 0 (= true)
aus. Das bedeutet, die folgenden Kommandos werden ausgefuehrt.

\begin{verbatim}
#!/bin/sh
if grep Bash file.txt
then echo "File contains at least one occurrence of Bash."
fi
\end{verbatim}

Es existiert auch ein verwandtes Kommando: \texttt{{[}...{]}}. Dieser
Ausdruck ist ein Synonym fuer das Bash-Kommando \texttt{test}. Es
existiert außerdem ein externes Kommando \texttt{/usr/bin/test}.

\begin{verbatim}
if [condition1 ]
then
   command1
   command2
   command3
elif [condition2 ]
# Same as else if
then
   command4
   command5
else
   default-command
fi
\end{verbatim}

Weitere Informationen zum Kommando \texttt{test} bzw. \texttt{{[}...{]}}
entnehmen Sie bitte der jeweiligen \texttt{man}-Page.

\subsection{Statement for~\ldots{}~do}\label{statement-fordo}

Syntax: \texttt{for\ Name\ {[}in\ Wort\ {]}\ do\ Liste\ done}

Mit \texttt{Name} wird eine Shellvariable definiert, die in jedem
Schleifendurchlauf einen neuen Wert erhaelt. Die Werte werden
normalerweise mit dem Schluesselwort \texttt{in} uebergeben. Wird der
Teil \texttt{in\ Wort} weggelassen, wird die Liste fuer jeden gesetzten
Parameter \href{node3.html\#ssec:positionsparameter}{2.7.1}) einmal
ausgefuehrt.

\begin{verbatim}
#! /bin/sh
for planet in Mercury Venus Earth Mars Jupiter Saturn Uranus
do
  echo $planet
done
# oder aber auch
NUMBERS="9 7 3 8 37.53"
for number in `echo $NUMBERS`  # for number in 9 7 3 8 37.53
do
  echo "$number "
done
\end{verbatim}

\subsection{Statement while und until}\label{statement-while-und-until}

Syntax: \texttt{while\ Liste\ do\ Liste\ done}\\
Syntax: \texttt{until\ Liste\ do\ Liste\ done}

Der Schleifenkörper \texttt{do\ Liste\ done} wird so lange wiederholt ,
bis die in \texttt{while\ Liste} formulierte Bedingung falsch ist.

Die \texttt{until}-Schleife entspricht der \texttt{while}-Schleife mit
dem Unterschied, daß der \texttt{do}-Teil so lange ausgefuehrt wird, wie
das letzte Kommando der \texttt{until\ Liste} einen Status ungleich 0
liefert.

\begin{verbatim}
#!/bin/sh
var0=0
LIMIT=10

while ["$var0" -lt "$LIMIT" ]
do
  echo -n "$var0 "        # -n suppresses newline.
  var0=`expr $var0 + 1`   # var0=$(($var0+1)) also works.
done
\end{verbatim}

\subsection{case Statement}\label{case-statement}

Syntax:
\texttt{case\ Wort\ in\ {[}Muster\ {[}\textbar{}\ Muster\ {]})\ Liste\ ;;\ ...~{]}\ esac}

Mit der \texttt{case}-Anweisung können Verzweigungen programmiert
werden. \texttt{Wort} wird mit den angegebenen Mustern verglichen. Bei
uebereinstimmung wird die \texttt{Liste} von Kommandos ausgefuehrt. In
den Suchmustern können auch Wildcards und regulaere Ausdruecke verwendet
werden.

\begin{verbatim}
#!/bin/sh
arch=$1
case $arch in
  i386 ) echo "80386-based machine";;
  i486 ) echo "80486-based machine";;
  i586 ) echo "Pentium-based machine";;
  i686 ) echo "Pentium2+-based machine";;
  *    ) echo "Other type of machine";;
esac
\end{verbatim}

\section{Arithmetik}\label{arithmetik}

Arithmetische Operationen werden ueber die Shellkommados \texttt{expr}
und \texttt{let} realisiert. Dabei ist \texttt{let} ein internes
Kommando der Bash, und \texttt{expr} ein Externes. Es ist sowohl möglich
Brechnungen mit Hilfe des Kommandoaufrufes zu machen, als auch durch
eine verkuerzte Schreibweise:

\begin{verbatim}
#!/bin/sh
z=`expr $z + 3` # Aufruf des externen Kommandos expr
let z=z+3    # Aufruf des internen Kommandos
let "z += 3" # Mit Quotes sind Leerzeichen und special operators erlaubt.
z=$(($z+3))  # neue verkuerzte Schreibweise (ab Version 2.0)
z=$[$z+3]    # alte Schreibweise
\end{verbatim}

Berechnungen finden, wie in C, mit ``lange Ganzzahlwerten'' statt. Eine
ueberlaufkontrolle gibt es nicht. Division durch Null fuehrt zu einem
Fehler, der aber mit Hilfe der \texttt{trap}-Shellfunktion abgefangen
werden kann. Folgende Operatoren sind erlaubt (Prioritaetshirarchie):

\begin{longtable}[c]{@{}ll@{}}
\toprule
+ - & Vorzeichen\tabularnewline
! \texttt{\textasciitilde{}} & logische und bitweise
Negation\tabularnewline
\texttt{*} / \% & Multiplikation, Division, Modulo\tabularnewline
+ - & Addition und Subtraktion\tabularnewline
\texttt{\textless{}\textless{}\ \textgreater{}\textgreater{}} & bitweise
links und rechts-Shift-Operation\tabularnewline
\textless{}= \textgreater{}= \textless{}\textgreater{} &
Vergleiche\tabularnewline
== != & gleich und ungleich\tabularnewline
\texttt{\&} & bitweise Addition\tabularnewline
\texttt{\textasciitilde{}} & bitweise XOR\tabularnewline
\textbar{} & bitweise ODER\tabularnewline
\texttt{\&\&} & bitweise UND\tabularnewline
\textbar{}\textbar{} & logisches ODER\tabularnewline
\bottomrule
\end{longtable}

\section{Funktionen}\label{funktionen}

Wie auch in C, kann man in der Bash einzelne Programmteile zu Funktionen
zusammenfassen. Mit dem \texttt{local}-Shellkommando ist es möglich,
lokale Variablen fuer Scriptfunktionen zu erzeugen. Mit \texttt{return}
können Werte aus einer Funktion zurueckgegeben werden.

\begin{verbatim}
#! /bin/bash
myadd() {
        # $1 erstes Argument
        tmp=0
        args=$@
        for i in $args
        do
        tmp=`expr $tmp + $i`
        done
        return $tmp
}
# main
myadd 1 2 3 $VAR
RES=$?
myadd $RES 5 6 $VAR2
RES=$?
\end{verbatim}

\section{Ein-/Ausgabe-Umleitungen}\label{ein-ausgabe-umleitungen}

Jedes Programm erhaelt beim Start drei offene ''Datenkanaele``:

\begin{longtable}[c]{@{}ll@{}}
\toprule
Standard Input: & STDIN (0)\tabularnewline
Standard Output: & STDOUT (1)\tabularnewline
Standard Error Output: & STDERR (2)\tabularnewline
\bottomrule
\end{longtable}

Durch das Umlenken der Ein-/Ausgabekanaele können Dateien oder
Dateisysteme zum Lesen bzw. Schreiben fuer Kommandos geöffnet werden. Es
gibt viele Möglichkeiten Daten umzuleiten. Hier ist eine kleine Auswahl:

\begin{longtable}[c]{@{}ll@{}}
\toprule
\texttt{COMMAND\textless{}infile} & Eingabeumlenkung\tabularnewline
\texttt{COMMAND\textgreater{}outfile} & Ausgabeumlenkung\tabularnewline
\texttt{COMMAND»outfile} & Ausgabeumlenkung, anhaengen\tabularnewline
\texttt{COMMAND\ 2\textgreater{}\&1} & STDERR mit auf STDOUT
legen\tabularnewline
\texttt{COMMAND\ »EofListe\ Liste\ EofListe} & Zeilen in \emph{Liste}
werden in COMMAND umgeleitet\tabularnewline
\bottomrule
\end{longtable}

\section{Pipes}\label{pipes}

Bei einer Pipe wird der Standardausgabekanal eines Kommandos mit dem
Standardeingabekanal eines anderen Kommandos zusammengelegt. Dabei
werden beide Kommandos als separate Prozesse gleichzeitig gestartet.\\
Beim folgenden Beispiel wird der Inhalt der Datei .zshrc durch
\texttt{cat} auf den Standardausabekanal geschrieben und an
\texttt{grep} ueber den Standardeingabekanal uebergeben. \texttt{Grep}
sucht nach allen Zeilen die das Wort~ ``HISTSIZE'' enthalten, und gibt
diese aus.

\begin{verbatim}
asterix% cat .zshrc|grep -i HISTSIZE
export HISTSIZE=1000
\end{verbatim}

------------------------------------------------------------------------

\section{Textmanipulationen}\label{textmanipulationen}

In diesem Kapitel soll es um das komplexe Thema ``Suchen und Ersetzen''
gehen. Im Weiteren wird auf die Grundlagen eingegangen und zwei der
mächtigsten Tools auf diesem Gebiet kurz beleuchtet. Wer es wirklich
genau wissen will, sollte sich im Internet nach weiterführenden
Dokumentationen umsehen.

\section{reguläre Ausdrücke}\label{reguluxe4re-ausdruxfccke}

Es gibt in der UNIX-Welt einige sehr mächtige Tools (sed, awk, grep),
die das Durchsuchen von Texten nach bestimmten Mustern ermöglichen. Um
diese Tools effektiv nutzen zu können, ist es unbedingt notwendig, sich
mit regulären Ausdrücken zu beschäftigen.\\
Reguläre Ausdrucke beschreiben eine nicht leere Menge von Zeichenfolgen,
die aus Textzeichen (Buchstaben, Ziffern, Sonderzeichen) und/oder
Metazeichen mit erweiterter Bedeutung bestehen. Textzeichen stehen für
sich selbst, Metazeichen (Spezialzeichen) stellen Operatoren dar, mit
deren Hilfe komplexe Textmuster beschrieben werden können. Als
Begrenzung der Mustersuche gilt in den meisten Fällen (Tools) das
Zeilenende. D.h. es ist nicht möglich reguläre Ausdrücke zu definieren,
die über das Zeilenende hinaus prüfen.

\subsection{Zeichenklassen}\label{zeichenklassen}

\begin{longtable}[c]{@{}ll@{}}
\toprule
. & ist ein Platzhalter und bezeichnet jedes einzelne Zeichen außer das
Zeilenende.\tabularnewline
\texttt{{[}abc\${]}} & trifft alle aufgeführten Zeichen.\tabularnewline
\texttt{a-c} & bezeichnet alle Zeichen im angegebenen
Limit.\tabularnewline
\texttt{{[}\^{}exp{]}} & trifft alle Zeichen außer den
angegebenen.\tabularnewline
\texttt{\^{}abc} & trifft das angegebene Muster, wenn es am Zeilenanfang
steht.\tabularnewline
\texttt{abc\$} & trifft das angegebene Muster, wenn es am Zeilenende
steht.\tabularnewline
\texttt{\textbackslash{}} & Maskierung des folgenden Zeichens
\href{node3.html\#ssec:quotierung}{2.3.2})\tabularnewline
\bottomrule
\end{longtable}

\subsection{Wiederholungsoperatoren}\label{wiederholungsoperatoren}

\begin{longtable}[c]{@{}ll@{}}
\toprule
\texttt{*} & trifft den vorangegangenen Ausdruck 0 oder
mehrmals.\tabularnewline
+ & trifft den vorangegangenen Ausdruckt ein oder
mehrmals.\tabularnewline
\texttt{?} & trifft den vorangegangenen Ausdruck 0 oder
einmal.\tabularnewline
\texttt{\textbar{}} & ist ein Trennzeichen. Trifft entweder den
folgenden oder vorangegangenen Ausdruck.\tabularnewline
(\ldots{}) & bildet eine Gruppe von regulären Ausdrücken.\tabularnewline
\bottomrule
\end{longtable}

Die Syntax von \texttt{grep} und \texttt{egrep} variiert in manchen
Punkten. Für +, ?, \textbar{}, (\ldots{}) ergibt sich für \texttt{grep}
eine andere Schreibweise: \texttt{\textbackslash{}}+, \texttt{?},
\texttt{\textbar{}},
\texttt{\textbackslash{}(}\ldots{}\texttt{\textbackslash{})}.

Reguläre Ausdrücke werden von links nach rechts aufgelöst. Operatoren
werden in der folgenden Reihenfolge abgearbeitet:

\texttt{{[}}\ldots{} \texttt{{]}}~ ? + * Verkettung Verknüpfungen
\textbar{}

Abweichungen davon können mit Klammerung einzelner Ausdrücke erreicht
werden.

Die Operatoren ?, +, *, \texttt{\^{}}, \$ und \textbar{} können wiederum
auch auf gruppierte (geklammerte) Ausdrücke angewendet werden.
Beispielsweise trifft

\texttt{(AB\textbar{}CD+)?(EF)+}

die Zeichenketten ABEF, CDEF,CDDEF, EFEF, EFEFEF usw.

Das hinter dem ersten Klammernpaar stehende Fragezeichen bedeutet, daß
das Vorkommen, der darin enthaltenden Zeichenketten AB und CD, optional
ist. Das Pluszeichen hinter D sagt aus, daß nach einem oder mehreren D's
gesucht wird (CD, CDD, CDDDD, \ldots{}). Die so gefundenen Zeichenketten
der ersten Klammer, müssen unmittelbar gefolgt sein von mindestens einem
Vorkommen der Zeichenkette EF. Das Plus bezieht sich hier auf den ganzen
Klammerausdruck.

Wie aus obigen Regeln zu ersehen ist, handelt es sich bei regulären
Ausdrücken um eine Wissenschaft. Die hier aufgezeigten Muster stellen
nur einen Auszug dar. Noch ein paar Beispiele hinterher:

\begin{longtable}[c]{@{}ll@{}}
\toprule
.aus & trifft Haus, raus, Maus, Laus,\ldots{}\tabularnewline
\texttt{xy*z} & trifft auf xy\ldots{}was auch
immer\ldots{}z\tabularnewline
\texttt{\^{}abc} & jede Zeile, die mit abc beginnt\tabularnewline
\texttt{abc\$} & jede Zeile, die mit abc endet\tabularnewline
\texttt{\textbackslash{}*} & trifft jeden Stern\tabularnewline
\texttt{{[}Mr{]}aus} & trifft Maus und raus\tabularnewline
\texttt{{[}{[}abc{]}} & trifft \texttt{{[}} (muß am Anfang stehen), a,
b, c\tabularnewline
\texttt{{[}KT{]}?ELLER} & trifft ELLER, TELLER, KELLER\tabularnewline
\texttt{{[}\^{}a-zA-Z{]}} & schließt alle Buchstaben aus\tabularnewline
\texttt{{[}0-9{]}\$} & trifft jede Zeile, die mit einer Zahl
endet\tabularnewline
\texttt{{[}0-9{]}{[}0-9{]}} & trifft jede zweistellige
Nummer\tabularnewline
\texttt{H(e\textbar{}a)llo} & trifft Hallo und Hello\tabularnewline
\texttt{(ab)?} & trifft entweder ``ab'`oder nichts (``ab'' ist
optional)\tabularnewline
\texttt{\^{}\$} & trifft alle Leerzeilen\tabularnewline
\bottomrule
\end{longtable}

Aber es ist noch mehr möglich.

\begin{longtable}[c]{@{}ll@{}}
\toprule
\texttt{\textbackslash{}\{n,m\textbackslash{}\}} & trifft ein Muster
mindestens n-mal und höchstens m-mal\tabularnewline
\texttt{\textbackslash{}}\textless{}\texttt{abc\textbackslash{}}\textgreater{}
& trifft das eingeschlossene Muster nur, wenn es sich um ein separates
Wort handelt\tabularnewline
\texttt{\textbackslash{}(abc\textbackslash{})} & Die Klammern fassen
Ausdrücke zusammen. Jede Zeile wird nach angegebenen Muster durchsucht
und jeder Treffer wird in einem Puffer gespeichert (max. 9 dieser Muster
sind in einem Befehl möglich).\tabularnewline
\texttt{\textbackslash{}n} & referenziert obige Muster\tabularnewline
\bottomrule
\end{longtable}

Es lassen sich des weiteren syntaktische Gruppen bilden. Hierbei handelt
es sich nur um eine andere Schreibweise bereits besprochener Ausdrücke.
Diese Schreibweise kann die Lesbarkeit regulärer Ausdrücke deutlich
verbessern.

\begin{longtable}[c]{@{}ll@{}}
\toprule
\texttt{{[}}:alnum:\texttt{{]}} & alle alphanumerischen Zeichen
{[}A-Za-z0-9{]}\tabularnewline
\texttt{{[}}:alpha:\texttt{{]}} & alle Buchstaben
{[}A-Za-z{]}\tabularnewline
\texttt{{[}}:blank:\texttt{{]}} & ein oder mehrere Leerzeichen und
Tab\tabularnewline
\texttt{{[}}:cntrl:\texttt{{]}} & alle Kontrollzeichen wie z.B.
\textless{}newline\textgreater{}\tabularnewline
\texttt{{[}}:digit:\texttt{{]}} & alle dezimalen Zahlen
{[}0-9{]}\tabularnewline
\texttt{{[}}:graph:\texttt{{]}} & alle druckbaren Zeichen (ASCII 33 -
126) ohne das Leerzeichen\tabularnewline
\texttt{{[}}:print:\texttt{{]}} & alle druckbaren Zeichen\tabularnewline
\texttt{{[}}:lower:\texttt{{]}} & alle Kleinbuchstaben
{[}a-z{]}\tabularnewline
\texttt{{[}}:upper:\texttt{{]}} & alle Großbuchstaben
{[}A-Z{]}\tabularnewline
\texttt{{[}}:space:\texttt{{]}} & Leerzeichen und horizontales
Tab\tabularnewline
\texttt{{[}}:xdigit:\texttt{{]}} & alle hexadezimalen Zahlen
{[}0-9A-Fa-f{]}\tabularnewline
\bottomrule
\end{longtable}

Reguläre Ausdrücke sind zwar allgemein gültig, jedoch ist der
Funktionsumfang der einzelnen Tools nicht einheitlich.

\begin{longtable}[c]{@{}llllllllll@{}}
\toprule
~ & \texttt{{[}}\ldots{}\texttt{{]}} & . & \texttt{*} & ? & + &
\texttt{\^{}} & \$ & \textbar{} & \texttt{()}\tabularnewline
grep & x & x & x & ~ & ~ & x & x & ~ & ~\tabularnewline
egrep & x & x & x & x & x & x & x & x & x\tabularnewline
sed & x & x & x & ~ & ~ & x & x & x & x\tabularnewline
awk & ~~~x~~~ & ~~~x~~~ & ~~~x~~~ & ~~~x~~~ & ~~~x~~~ & ~~~x~~~ &
~~~x~~~ & ~~~x~~~ & ~~x~~~\tabularnewline
\bottomrule
\end{longtable}

\section{{[}rep}\label{rep}

\begin{longtable}[c]{@{}ll@{}}
\toprule
Syntax: &
\texttt{grep\ {[}-CVbchilnsvwx{]}\ {[}-Anzahl{]}\ {[}-AB\ Anzahl{]}\ {[}{[}-e{]}\ Ausdruck\ \textbar{}\ -f\ Datei{]}\ {[}Datei...{]}}\tabularnewline
\bottomrule
\end{longtable}

\texttt{grep} durchsucht die angegebenen Dateien (oder die Daten aus der
Standardeingabe) nach einem Ausdruck und gibt die entsprechenden Zeilen
aus. Der Status von grep ist 0, wenn der Ausdruck gefunden wurde und
sonst 1.

Wieder ein paar einfache Beispiele:

\begin{longtable}[c]{@{}lllll@{}}
\toprule
Befehl & cat file & grep b.*g file & grep b.*g. file & grep ggg*
file\tabularnewline
Resultat & big & big & bigger & bigger\tabularnewline
~ & bad bug & bad bug & boogy & ~\tabularnewline
~ & bag & bag & ~ & ~\tabularnewline
~ & bigger & bigger & ~ & ~\tabularnewline
~ & boogy & boogy & ~ & ~\tabularnewline
\bottomrule
\end{longtable}

Stern und Punkt sind Sonderzeichen. Will man nach Mustern suchen, die
den Punkt als literarisches Zeichen auffassen, so muß dieser maskiert
werden.

\texttt{ls\ \textbar{}\ grep\ Name.ext}

trifft auch Name0ext , NameBext , usw. .

\texttt{ls\ \textbar{}\ grep\ Name\textbackslash{}.ext}

trifft nur die Datei File mit mit dem Namen \texttt{Name.ext}. .

Wir wollen in einem Textfile alle Zeilen, die den Namen Fred Feuerstein
und Fredericke Feuerstein enthalten. Das bedeutet der Teil ``ericke''
ist optional.

\texttt{grep\ "Fred\textbackslash{}(ericke\textbackslash{})\textbackslash{}?\ Feuerstein"\ textfile}

Die Klammern bilden eine Gruppe. Das Fragezeichen bedeutet ein oder kein
Vorkommen des vorherigen Musters.

Hier werden Klammern innerhalb anderer Klammern ausgeschlossen:

\texttt{grep\ "({[}\^{}(){]}*)"}

Trifft \texttt{(hello)} und \texttt{(aksjdhaksj\ d\ ka)} aber nicht
\texttt{x=(y+2(x+1))} .

Jetzt wollen wir nach sich wiederholenden Mustern suchen. Eine gutes
Beispiel sind Telefonnummern. Wir suchen nach einer Vorwahl (3 Ziffern)
und der Nummer (7 Ziffern), getrennt durch einen - , einem Leerzeichen
oder garnicht.

\texttt{grep\ "{[}0-9{]}\textbackslash{}\{3\textbackslash{}\}{[}-{]}\textbackslash{}?{[}0-9{]}\textbackslash{}\{7\textbackslash{}\}"\ file}

\texttt{{[}0-9{]}} steht für alle Zahlen,
\texttt{\textbackslash{}\{3\textbackslash{}\}} besagt, daß sich das
vorherige Muster 3 mal wiederholen soll.
\texttt{{[}-{]}\textbackslash{}?} repräsentiert die Auswahl des
Trennzeichens (Leerzeichen, - oder garnichts).

Angenommen, wir suchen eine Zeile in der nur das Wort ``Hallo'`steht. Es
ist zudem noch möglich, daß sich vor und/oder hinter ``Hallo''
Leerzeichen befinden. Eine Möglichkeit wäre folgendes

\texttt{grep\ "\^{}{[}{[}:space:{]}{]}*Hallo{[}{[}:space:{]}{]}*\$"\ file}

\texttt{\^{}} steht für den Zeilenanfang, \texttt{\$} für das
Zeilenende.

Manchmal ist es nötig, Zeilen zu suchen, in denen entweder das Eine oder
das Andere steht.

\texttt{grep\ "Ich\ habe\ \textbackslash{}(Schröder\textbackslash{}\textbar{}Stoiber\textbackslash{})\ gewählt"\ file}

\texttt{\textbackslash{}\textbar{}} entspricht einem logischen ODER.

Hat man einmal ein Muster in
\texttt{\textbackslash{}(}\ldots{}\texttt{\textbackslash{})} definiert,
kann man es mit \texttt{\textbackslash{}Zahl} erneut einsetzen.

\texttt{echo\ bla\ blub\ bla\ \textbar{}\ grep\ \textquotesingle{}\textbackslash{}(bla\textbackslash{}).*\textbackslash{}1\textquotesingle{}}

\section{sed Stream Editor}\label{sed-stream-editor}

\begin{longtable}[c]{@{}ll@{}}
\toprule
Syntax: &
\texttt{sed\ {[}-n{]}\ {[}-e\ Editorkommando{]}\ {[}-f\ Sriptdatei{]}\ {[}inputfile{]}}\tabularnewline
\bottomrule
\end{longtable}

\texttt{sed} ist ein Editor zur automatischen Textbearbeitung. Die
Bearbeitung erfolgt mit Editorkommandos, die dem \texttt{sed} in einer
separaten Scriptdatei oder direkt in der Kommandozeile übergeben werden.
Um in der Kommandozeile mehrere Editorkommandos zu übergeben, kann die
-e Option mehrfach verwendet werden. Die Editorkommandos können auch
durch ein Semikolon getrennt werden. Wird nur ein einziges
Editorkommando in der Kommandozeile übergeben, kann die Kennzeichnung
mit der -e Option auch weggelassen werden. Damit die Shell keine
Veränderungen an der Zeichenkette mit dem Editorkommando vornimmt, muß
sie in Hochkommata eingeschlossen werden.

Eine Scriptdatei kann beliebig viele Editorkommandos enthalten, die
durch Zeilenende oder Semikolon von einander getrennt werden müssen.

Jedes Kommando besteht aus einem Adressteil und einem Funktionsteil. Der
Adressteil gibt an, welche Zeilen einer Textdatei mit diesem Kommando
bearbeitet werden sollen, und der Funktionsteil beschreibt die
Veränderung, die an den im Adressteil bestimmten Zeilen vorgenommen
werden soll. Wenn kein Adressteil angegeben ist, wird die Funktion mit
jeder Zeile ausgeführt.

Die Bearbeitung eines Textes erfolgt, indem die Eingabe zeilenweise in
einen Arbeitsspeicher gelesen wird, und dann die Adressteil aller
Editorkommandos der Reihe nach mit dem Text im Arbeitsspeicher
verglichen werden. Die Funktionen der passenden Kommandos werden in der
Reihenfolge ihres Auftretens ausgeführt. Normalerweise wird nach der
Bearbeitung aller Kommandos der Inhalt des Arbeitsspeichers auf die
Standardausgabe ausgegeben und danach durch die nächste Eingabezeile
ersetzt. Die automatische Ausgabe des Arbeitsspeichers nach jeder Zeile
kann mit der Option -n unterdrückt werden.

Zusätzlich zu dem Arbeitsspeicher gibt es noch einen Zwischenspeicher
(Puffer), der von verschiedenen Funktionen benutzt werden kann.

Der Arbeitsspeicher kann auch mehrere Zeilen auf einmal enthalten.

Im Adressteil können die Zeilen entweder durch ihre Zeilennummern, oder
durch reguläre Ausdrücke ausgewählt werden. Alle Funktionen außer den a,
i, q und = akzeptieren einen Adressbereich, bei dem eine Start- und eine
Endadresse durch ein Komma getrennt angegeben werden. Ein Dollarzeichen
steht für die letzte Zeile. Wenn eine Endadresse mit einem regulären
Ausdruck bezeichnet ist, wird die erste passende Zeile als Bereichsende
eingesetzt.

Reguläre Ausdrücke müssen in einfachen Schrägstrichen (Slashes /)
eingeschlossen werden. \texttt{sed} benutzt die gleichen Routinen zur
Auswertung regulärer Ausdrücke wie emacs oder grep. Darüberhinaus kann
auch die an die \texttt{sed} Syntax angelehnte Konstruktion
\texttt{\textbackslash{}\#Muster\textbackslash{}\#} (mit jedem
beliebigen Zeichen für \texttt{\textbackslash{}\#}) benutzt werden, die
wie /Muster/ interpretiert wird.

Im Muster kann auch ein \texttt{\textbackslash{}n} vorkommen, das auf
das Zeilenende paßt.

\subsection{\texorpdfstring{Optionen von
\texttt{sed}}{Optionen von sed}}\label{optionen-von-sed}

Mit \texttt{sed} gibt es schier unendliche Möglichkeiten der
Textmanipulation. \texttt{sed} bietet unter anderem folgende
Funktionalität:

\begin{longtable}[c]{@{}lll@{}}
\toprule
Operator & Name & Effekt\tabularnewline
\texttt{{[}}Muster/Adressraum\texttt{{]}}/p & print & gibt den mit
\texttt{{[}}Muster/Adressraum\texttt{{]}} gekennzeichneten Bereichs
aus.\tabularnewline
\texttt{{[}}Adressraum\texttt{{]}}/d & delete & Löschen des mit
\texttt{{[}}angegebener Adressraum\texttt{{]}} gekennzeichneten
Bereichs.\tabularnewline
s/Muster1/Muster2/ & substitute & Ersetze das erste in einer Zeile
auftretende Muster1 durch Muster2.\tabularnewline
\texttt{{[}}Adressraum\texttt{{]}}/s/Muster1/Muster2/ & substitute &
Ersetze über einen angegebenen Adressraum das erste in einer Zeile
auftrettende Muster1 durch Muster2.\tabularnewline
\texttt{{[}}Adressraum\texttt{{]}}/y/Muster1/Muster2/ & transform &
Transformiere über einen angegebenen Adressraum, jedes Zeichen in
Muster1 durch das korrespondierende Zeichen in Muster2 (äquivalent zum
Befehl \texttt{tr}.)\tabularnewline
g & global & Wendet das vorherstehende Kommando auf jedes vorkommende
Ersetzungsmuster einer Zeile an.\tabularnewline
\texttt{{[}}Anzahl\texttt{{]}}q & quit & beendet \texttt{sed} nach
``Anzahl'' Zeilen.\tabularnewline
\texttt{{[}}Muster/Adressraum\texttt{{]}}/w \texttt{file} & write &
Schreibt gefundene Zeilen in \texttt{file}.\tabularnewline
i Text insert fügt Text vorher ein & &\tabularnewline
a Text append fügt Text danach ein & &\tabularnewline
c Text change ersetzt durch Text & &\tabularnewline
= & ~ & Gibt die aktuelle Eingabezeilennummer aus.\tabularnewline
\{\ldots{}\} & ~ & Die von den Klammern eingeschlossenen und durch
Zeilenende oder Semikolon getrennten Funktionen, werden als Einheit
behandelt.\tabularnewline
\bottomrule
\end{longtable}

\subsection{Beispiele}\label{beispiele}

Im ersten Beispiel soll das Wort ``UNIX'`durch das Wort ``Linux'`ersetzt
werden. Das abschließende g sorgt dafür, daß \textbf{jedes} in einer
Zeile befindliche ``UNIX'`durch ``Linux'`ersetzt wird. Ohne g würde nur
das erste auftretende ``UNIX'' ersetzt. Der Befehl ist in Hochkommata
eingefaßt, damit Sonderzeichen nicht von der Shell interpretiert werden
(in diesem Fall die Klammern). Ohne die Hochkommata sieht der Befehl
etwas anders aus. Klammern und Leerzeichen müssen maskiert werden.

\texttt{sed\ \textquotesingle{}s/UNIX\ (TM)/Linux/g\textquotesingle{}\ file}\\
\texttt{sed\ -e\ s/UNIX\textbackslash{}\ \textbackslash{}(TM\textbackslash{})/Linux/g\ file}

Es ist möglich die Befehlsfolgen, die \texttt{sed} abarbeiten soll, in
einer Scriptdatei zu speichern. Die Ausgabe läßt sich auf dem üblichen
Wege in eine Datei umleiten. Der Befehl sieht dann so aus:

\texttt{sed\ -n\ -f\ muster\_file\ inputfile\ \textgreater{}outputfile}

Normalerweise gelten die vergegebenen Muster immer für den gesamten
Text. Aber es ist auch möglich bestimmte Zeilen und Bereiche zu
adressieren. Dies kann mit Zahlen, Mustern und mit dem \$-Zeichen, als
Kennung für die letzte Zeile, geschehen. Mit dem ! können Zeilen
ausgeschlossen werden. Die Syntax sieht dann folgendermaßen aus:

{[}\emph{Adresse1}{]},{[}\emph{Adresse2}{]} \emph{Kommando}
{[}\emph{Parameter}{]}

Beispiele sagen mehr als tausend Worte:

\texttt{sed\ \textquotesingle{}/10,\$/\ s/WWJD/TWJD/g\textquotesingle{}\ file}\\
\texttt{sed\ \textquotesingle{}/Josef/\ s/WWJD/TWJD/g\textquotesingle{}\ file}\\
\texttt{sed\ \textquotesingle{}1!s/WWJD/TWJD/g\textquotesingle{}\ file}

Im erste Beispiel wird von Zeile 10 bis zum Dateiende der String
``WWJD'`in ``TWJD'`geändert. Im zweiten Beispiel wird nur in Zeilen
ersetzt, in denen das Wort ``Josef'`vorkommt. Das letzte Beispiel
verändert ``WWJD'`in ``TWJD'' überall, außer in der ersten Zeile.

Noch ein paar nützliche Muster:

\begin{longtable}[c]{@{}ll@{}}
\toprule
\texttt{8d} & löscht die achte Zeile\tabularnewline
\texttt{/\^{}\$/d} & löscht alle leeren Zeilen\tabularnewline
\texttt{1,/\^{}\$/d} & löscht alles von Zeile 1 bis einschließlich der
ersten leeren Zeile\tabularnewline
\texttt{/GUI/d} & löscht alle Zeilen in denen ``GUI''
vorkommt\tabularnewline
\texttt{/Jones/p} & gibt nur Zeilen aus in denen der Name ``Jones''
vorkommt (mit \texttt{-n})\tabularnewline
\texttt{1,10\ p} & gibt Zeilen 1 bis 10 aus (mit
\texttt{-n})\tabularnewline
\texttt{/\^{}begin/,/\^{}end/p} & gibt jede Zeile aus, die sich zwischen
Zeilen die mit ``begin'`und ``end'' am Zeilenanfang
befindet\tabularnewline
\texttt{s/Windows/Linux/} & ersetzt das erste in einer Zeile
vorkommende, ``Windows'`mit ``Linux''\tabularnewline
\texttt{s/BSOD/stability/g} & setzt ``stability'`für jedes ``BSOD''
ein\tabularnewline
\texttt{s/00*/0/g} & ersetzt ``00'`, ``000'`, \ldots{}mit
``0''\tabularnewline
\texttt{s/GUI//g} & löscht ``GUI'' in jeder Zeile\tabularnewline
\texttt{/\^{}{[}0-9{]}/s/\^{}/\ /} & alle Zeilen, die mit einer Zahl
beginnen, um 3 Leerzeichen einrücken\tabularnewline
\texttt{/\^{}\$/s/\^{}/XXX/} & alle leeren Zeilen mit ``XXX''
auffüllen\tabularnewline
\texttt{10q} & zeigt die ersten 10 Zeilen an\tabularnewline
\texttt{/\^{}X/w\ file} & schreibt alle Zeilen, die mit ``X'' beginnen,
in \texttt{file}\tabularnewline
\bottomrule
\end{longtable}

Kniffeliger wird die Angelegenheit, wenn es sich um die Optionen i, a
und c handelt:

\begin{verbatim}
#!/usr/bin/sed -nf

/ganz bestimmter Text/{
  i\
  Text gehört davor
  a\
  Text der danach stehen soll
}
\end{verbatim}

Kommando und Ergebnis sehen dann so aus:

\begin{verbatim}
asterix% echo 'ganz bestimmter Text' | sed -f scriptdatei
Text gehört davor
ganz bestimmter Text
Text der danach stehen soll
asterix%
\end{verbatim}

Aber es geht natürlich auch ohne Scriptdatei:

\begin{verbatim}
asterix% echo 'ganz bestimmter Text' | \
sed -e '/ganz bestimmter Text/{;i\' \
-e 'Text gehört davor' -e 'a\' -e 'Text der danach stehen soll' -e ' }'
\end{verbatim}

An diesem Beispiel kann man des weiteren erkennen, daß es möglich ist,
Befehlsgruppen zu bilden. Eine Gruppe wird durch die geschweiften
Klammern zusammengefaßt. Das angegebene Suchmuster `'/ganz bestimmter
Text/'' wird dadurch von a und i gemeinsam genutzt.

Nichts verstanden? Macht nichts, es ist auch nicht einfach! Im Internet
gibt es eine Vielzahl von Tutorien zu regulaeren Ausdruecken, sowie zu
\texttt{sed} und \texttt{grep}. Und wie immer kann auch ein Blick in die
\texttt{man}-Page nicht schaden. {[}LE,RO{]} {[}LO,RE{]}

~

~ Pawel Slabiak 2004-08-02

\hypertarget{refs}{}

\end{document}
